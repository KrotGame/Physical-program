import streamlit as st
import numpy as np
import plotly.graph_objects as go
from scipy.integrate import solve_ivp

st.title("üìà –í–∏–º—É—à–µ–Ω—ñ –∫–æ–ª–∏–≤–∞–Ω–Ω—è —Ç–∞ –†–µ–∑–æ–Ω–∞–Ω—Å")
st.write("–ú–æ–¥–µ–ª—å –æ—Å—Ü–∏–ª—è—Ç–æ—Ä–∞ –∑ –∑–∞—Ç—É—Ö–∞–Ω–Ω—è–º —Ç–∞ –∑–æ–≤–Ω—ñ—à–Ω—å–æ—é —Å–∏–Ω—É—Å–æ—ó–¥–∞–ª—å–Ω–æ—é —Å–∏–ª–æ—é.")
st.latex(r"m \ddot{x} + b \dot{x} + k x = F_0 \cos(\omega_d t)")

# --- –ë—ñ—á–Ω–∞ –ø–∞–Ω–µ–ª—å ---
st.sidebar.header("–ü–∞—Ä–∞–º–µ—Ç—Ä–∏ –æ—Å—Ü–∏–ª—è—Ç–æ—Ä–∞")
m = st.sidebar.slider("–ú–∞—Å–∞ (m), –∫–≥", 0.1, 10.0, 1.0, key="m_res")
k = st.sidebar.slider("–ñ–æ—Ä—Å—Ç–∫—ñ—Å—Ç—å –ø—Ä—É–∂–∏–Ω–∏ (k), –ù/–º", 0.1, 50.0, 10.0, key="k_res")
b = st.sidebar.slider("–ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –∑–∞—Ç—É—Ö–∞–Ω–Ω—è (b)", 0.0, 5.0, 0.5, key="b_res")

st.sidebar.header("–ó–æ–≤–Ω—ñ—à–Ω—è —Å–∏–ª–∞")
F0 = st.sidebar.slider("–ê–º–ø–ª—ñ—Ç—É–¥–∞ —Å–∏–ª–∏ (F‚ÇÄ), –ù", 0.0, 50.0, 10.0)
omega_d = st.sidebar.slider("–ß–∞—Å—Ç–æ—Ç–∞ —Å–∏–ª–∏ (œâ_d), —Ä–∞–¥/—Å", 0.1, 10.0, 3.0, 0.1)

t_max = st.sidebar.slider("–ß–∞—Å —Å–∏–º—É–ª—è—Ü—ñ—ó (T), —Å", 10.0, 200.0, 50.0)

# --- –†–æ–∑—Ä–∞—Ö—É–Ω–∫–æ–≤–∞ —á–∞—Å—Ç–∏–Ω–∞ ---

# 1. –í–ª–∞—Å–Ω–∞ —á–∞—Å—Ç–æ—Ç–∞
omega0 = np.sqrt(k / m)
# 2. –†–µ–∑–æ–Ω–∞–Ω—Å–Ω–∞ —á–∞—Å—Ç–æ—Ç–∞ (—Ç—Ä–æ—Ö–∏ –∑–º—ñ—â—É—î—Ç—å—Å—è —á–µ—Ä–µ–∑ –∑–∞—Ç—É—Ö–∞–Ω–Ω—è)
omega_res = np.sqrt(omega0**2 - (b/(2*m))**2) if (b/(2*m)) < omega0 else 0

st.subheader("–ö–ª—é—á–æ–≤—ñ —á–∞—Å—Ç–æ—Ç–∏ —Å–∏—Å—Ç–µ–º–∏")
col1, col2 = st.columns(2)
col1.metric("–í–ª–∞—Å–Ω–∞ —á–∞—Å—Ç–æ—Ç–∞ (œâ‚ÇÄ)", f"{omega0:.3f} —Ä–∞–¥/—Å")
col2.metric("–†–µ–∑–æ–Ω–∞–Ω—Å–Ω–∞ —á–∞—Å—Ç–æ—Ç–∞ (œâ_res)", f"{omega_res:.3f} —Ä–∞–¥/—Å", 
            help="–ß–∞—Å—Ç–æ—Ç–∞, –Ω–∞ —è–∫—ñ–π –∞–º–ø–ª—ñ—Ç—É–¥–∞ –±—É–¥–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ—é. –¢—Ä–æ—Ö–∏ –º–µ–Ω—à–∞ –∑–∞ œâ‚ÇÄ —á–µ—Ä–µ–∑ –∑–∞—Ç—É—Ö–∞–Ω–Ω—è.")

if np.isclose(omega_d, omega_res, atol=0.1):
    st.success("–í–∏ –±–ª–∏–∑—å–∫–æ –¥–æ —Ä–µ–∑–æ–Ω–∞–Ω—Å—É! –ê–º–ø–ª—ñ—Ç—É–¥–∞ –º–∞—î –±—É—Ç–∏ –≤–µ–ª–∏–∫–æ—é.")

# --- –†–æ–∑–≤'—è–∑–æ–∫ –î–† ---
# m*x'' + b*x' + k*x = F0*cos(w_d*t)
# y[0] = x
# y[1] = x' (—à–≤–∏–¥–∫—ñ—Å—Ç—å)
# y[0]' = y[1]
# y[1]' = (F0*cos(w_d*t) - b*y[1] - k*y[0]) / m
def model(t, y):
    x, v = y
    dxdt = v
    dvdt = (F0 * np.cos(omega_d * t) - b * v - k * x) / m
    return [dxdt, dvdt]

# –ü–æ—á–∞—Ç–∫–æ–≤—ñ —É–º–æ–≤–∏ (–∑—ñ —Å—Ç–∞–Ω—É —Å–ø–æ–∫–æ—é)
y0 = [0, 0]
t_span = [0, t_max]
t_eval = np.linspace(t_span[0], t_span[1], 1000)

sol = solve_ivp(model, t_span, y0, t_eval=t_eval)
x_values = sol.y[0]
t_values = sol.t

# --- –ì—Ä–∞—Ñ—ñ–∫ ---
st.header("–ì—Ä–∞—Ñ—ñ–∫ —Ä—É—Ö—É x(t)")
st.write("–°–ø—Ä–æ–±—É–π—Ç–µ –≤—Å—Ç–∞–Ω–æ–≤–∏—Ç–∏ '–ß–∞—Å—Ç–æ—Ç—É —Å–∏–ª–∏' (œâ_d) —Ä—ñ–≤–Ω–æ—é '–†–µ–∑–æ–Ω–∞–Ω—Å–Ω—ñ–π —á–∞—Å—Ç–æ—Ç—ñ' (œâ_res).")

fig = go.Figure()
fig.add_trace(go.Scatter(x=t_values, y=x_values, mode='lines', name='–ó–º—ñ—â–µ–Ω–Ω—è (x)'))
fig.update_layout(
    title="–ó–∞–ª–µ–∂–Ω—ñ—Å—Ç—å –∑–º—ñ—â–µ–Ω–Ω—è –≤—ñ–¥ —á–∞—Å—É x(t)",
    xaxis_title="–ß–∞—Å (t), —Å",
    yaxis_title="–ó–º—ñ—â–µ–Ω–Ω—è (x), –º"
)

# –ó–Ω–∞—Ö–æ–¥–∏–º–æ "—Å—Ç–∞–ª—É" –∞–º–ø–ª—ñ—Ç—É–¥—É (–ø—ñ—Å–ª—è –ø–µ—Ä–µ—Ö—ñ–¥–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—É)
# –ë–µ—Ä–µ–º–æ –æ—Å—Ç–∞–Ω–Ω—é —Ç—Ä–µ—Ç–∏–Ω—É —Å–∏–º—É–ª—è—Ü—ñ—ó
steady_state_amplitude = np.max(np.abs(x_values[int(len(x_values) * 2/3):]))
st.metric("–£—Å—Ç–∞–ª–µ–Ω–∞ –∞–º–ø–ª—ñ—Ç—É–¥–∞", f"{steady_state_amplitude:.3f} –º")